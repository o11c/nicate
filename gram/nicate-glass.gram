language nicate-glass

whitespace [\n\x20]+

keyword break
keyword case
keyword continue
keyword default
keyword do
keyword else
keyword enum
#keyword for
keyword fun
keyword goto
keyword if
keyword let
keyword return
keyword struct
keyword switch
keyword union
keyword while

atom comment \#[^\n]*
atom id [A-Za-z_][A-Za-z_0-9]*
atom decimal-floating-literal (([0-9]+\.|[0-9]*\.[0-9]+)([eE][-+]?[0-9]+)?|[0-9]+([eE][-+]?[0-9]+))[fFlL]?
atom hexadecimal-floating-literal 0[xX]([0-9a-fA-F]*\.[0-9a-fA-F]|[0-9a-fA-F]+\.?)(p[-+]?[0-9]+)[fFlL]?
atom decimal-literal [1-9][0-9]*
atom octal-literal 0[oO]?[0-7]*
atom hexadecimal-literal 0[xX][0-9a-fA-F]+
atom binary-literal 0[bB][01]+
atom character-literal \'([^\']|\\.)*\'
atom string-literal \"([^\"]|\\.)*\"

symbol '[' lbracket
symbol ']' rbracket
symbol '(' lparen
symbol ')' rparen
symbol '{' lbrace
symbol '}' rbrace
symbol '.' dot
symbol '->' arrow
symbol '++' incr
symbol '--' decr
symbol '&' ampersand
symbol '*' star
symbol '+' plus
symbol '-' minus
symbol '~' tilde
symbol '!' bang
symbol '/' slash
symbol '%' percent
symbol '<<' lshift
symbol '>>' rshift
symbol '<' lt
symbol '>' gt
symbol '<=' le
symbol '>=' ge
symbol '==' eq
symbol '!=' ne
symbol '^' caret
symbol '|' pipe
symbol '&&' logical-and
symbol '||' logical-or
#symbol '?' query
symbol ':' colon
symbol '=' assign
symbol '*=' star-assign
symbol '/=' slash-assign
symbol '%=' percent-assign
symbol '+=' plus-assign
symbol '-=' minus-assign
symbol '<<=' lshift-assign
symbol '>>=' rshift-assign
symbol '&=' ampersand-assign
symbol '^=' caret-assign
symbol '|=' pipe-assign
symbol ',' comma
symbol ';' semicolon
symbol '@' at

start tu

tu:
    tu? stmt
attr:
    '@' id
stmt:
    attr-stmt
    noattr-stmt
attr-stmt:
    attr attr-stmt                                          #annotated-statement
    union id maybe-struct-body                              #union-statement
    struct id maybe-struct-body                             #struct-statement
    enum id maybe-enum-body                                 #enum-statement
    fun fun-sig maybe-compound-stmt                         #fun-statment
    assign? ';'                                             #expr-statement
    let typed-id ';'                                        #declaration
    let typed-id '=' expr ';'                               #initialized-declaration
noattr-stmt:
    comment
    id ':' stmt                                             #labeled-statement
    default ':' stmt                                        #default-statement
    case expr ':' stmt                                      #case-statement
    while '(' expr ')' compound-stmt                        #while-statement
    do compound-stmt while '(' expr ')' ';'                 #do-statement
    goto id ';'                                             #goto-statement
    break ';'                                               #break-statement
    continue ';'                                            #continue-statement
    return expr? ';'                                        #return-statement
    switch '(' expr ')' compound-stmt                       #switch-statement
    if-or-compound-stmt
if-or-compound-stmt:
    compound-stmt
    if '(' expr ')' compound-stmt                           #if-statement
    if '(' expr ')' compound-stmt else if-or-compound-stmt  #if-else-statement
maybe-struct-body:
    ';'
    '{' typed-id-list? '}'                                  #struct-body
maybe-enum-body:
    ';'
    '{' id-list? '}'                                        #enum-body
fun-sig:
    '(' typed-id-list? ')' '->' expr
maybe-compound-stmt:
    ';'
    compound-stmt
compound-stmt:
    '{' stmt-list? '}'
typed-id:
    id ':' expr
typed-id-list:
    typed-id-list ',' typed-id                              #multi-typed-id-list
    typed-id
id-list:
    id-list ',' id                                          #multi-id-list
    id
expr-list:
    expr-list ',' expr                                      #multi-expr-list
    expr
stmt-list:
    stmt-list? stmt
assign:
    expr '=' assign                                         #simple-assign
    expr '*=' expr                                          #times-assign
    expr '/=' expr                                          #divide-assign
    expr '%=' expr                                          #modulo-assign
    expr '+=' expr                                          #plus-assign
    expr '-=' expr                                          #minus-assign
    expr '<<=' expr                                         #left-shift-assign
    expr '>>=' expr                                         #right-shift-assign
    expr '&=' expr                                          #bit-and-assign
    expr '^=' expr                                          #bit-xor-assign
    expr '|=' expr                                          #bit-or-assign
    expr
expr:
    logical-or-expr
mul-expr:
    unary-expr
    mul-expr '*' unary-expr                                 #times-expr
    mul-expr '/' unary-expr                                 #divide-expr
    mul-expr '%' unary-expr                                 #modulo-expr
add-expr:
    mul-expr
    add-expr '+' mul-expr                                   #plus-expr
    add-expr '-' mul-expr                                   #minus-expr
shift-expr:
    add-expr
    shift-expr '<<' add-expr                                #left-shift-expr
    shift-expr '>>' add-expr                                #right-shift-expr
cmp-expr:
    shift-expr
    shift-expr '<' shift-expr                               #lt-expr
    shift-expr '>' shift-expr                               #gt-expr
    shift-expr '<=' shift-expr                              #le-expr
    shift-expr '>=' shift-expr                              #ge-expr
    shift-expr '==' shift-expr                              #eq-expr
    shift-expr '!=' shift-expr                              #ne-expr
bitwise-and-expr:
    cmp-expr
    bitwise-and-expr '&' cmp-expr                           #bit-and-expr
bitwise-xor-expr:
    bitwise-and-expr
    bitwise-xor-expr '^' bitwise-and-expr                   #bit-xor-expr
bitwise-ior-expr:
    bitwise-xor-expr
    bitwise-ior-expr '|' bitwise-xor-expr                   #bit-ior-expr
logical-and-expr:
    bitwise-ior-expr
    logical-and-expr '&&' bitwise-ior-expr                  #log-and-expr
logical-or-expr:
    logical-and-expr
    logical-or-expr '||' logical-and-expr                   #log-or-expr
unary-expr:
    postfix-expr
    '++' unary-expr                                         #pre-incr-expr
    '--' unary-expr                                         #pre-decr-expr
    '&' unary-expr                                          #addressof-expr
    '+' unary-expr                                          #unary-plus-expr
    '-' unary-expr                                          #unary-minus-expr
    '~' unary-expr                                          #bit-not-expr
    '!' unary-expr                                          #log-not-expr
postfix-expr:
    primary-expr
    postfix-expr '[' expr-list? ']'                         #index-expr
    postfix-expr '(' expr-list? ')'                         #call-expr
    postfix-expr '.' id                                     #member-expr
    postfix-expr '++'                                       #post-incr-expr
    postfix-expr '--'                                       #post-decr-expr
primary-expr:
    id
    literal
# TODO decide whether to support `'(' assign ')'` or `'(' expr-list? ')'`
    '(' expr ')'                                            #paren-expr
literal:
    decimal-floating-literal
    hexadecimal-floating-literal
    decimal-literal
    octal-literal
    hexadecimal-literal
    binary-literal
    character-literal
    string-literal
